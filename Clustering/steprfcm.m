function [U_new, center, obj_fcn] = steprfcm(data, neighbors, U, cluster_n, beta, expo)
%STEPRFCM One step in robust fuzzy c-mean clustering.
%   [U_NEW, CENTER, ERR] = STEPRFCM(DATA, NEIGHBORS, U, CLUSTER_N, BETA, EXPO)
%   performs one iteration of robust fuzzy c-mean clustering, where
%
%   DATA: matrix of data to be clustered. (Each row is a data point.)
%   U: partition matrix. (U(i,j) is the MF value of data j in cluster j.)
%   CLUSTER_N: number of clusters.
%   BETA: coefficient that controls the trade off between fcm objective
%   function and spatial inconsistency penalty.
%   NEIGHBORS: a cell array which has n elements. n is the number of data.
%   Each cell contains the neighbor data indices correspond to each row in
%   DATA. It is generated by function roiNeighborsIndex.
%   EXPO: exponent (> 1) for the partition matrix.
%   U_NEW: new partition matrix.
%   CENTER: center of clusters. (Each row is a center.)
%   ERR: objective function for partition U.
%
%   Note that the situation of "singularity" (one of the data points is
%   exactly the same as one of the cluster centers) is not checked.
%   However, it hardly occurs in practice.
%
%   Reference: Pham, Dzung L. "Spatial models for fuzzy clustering." 
%   Computer vision and image understanding 84.2 (2001): 285-297.  
%
% See also DISTFCM, INITFCM, IRISFCM, FCMDEMO, RFCM, STEPFCM, 
% roiNeighborsIndex.

%   Authorship of original stepfcm.m
%   Roger Jang, 11-22-94.
%   Copyright 1994-2002 The MathWorks, Inc. 
%   $Revision: 1.13 $  $Date: 2002/04/14 22:21:02 $
%
% by Weiguang (Gavin) Ding, November 2013


mf = U.^expo;       % MF matrix after exponential modification
center = mf*data./((ones(size(data, 2), 1)*sum(mf'))'); % new center
dist = distfcm(center, data);       % fill the distance matrix

% compute the summation of neighbor-other membership, here called snom
snom = zeros(size(U));
% summation of other membership at each pixel, here called som
som = bsxfun(@minus, sum(mf, 1), mf);
data_n = size(data, 1);
for indCluster = 1 : cluster_n
    for indData = 1 : data_n
        snom(indCluster, indData) = sum(som(indCluster, neighbors{indData}));
    end
end


% objective function is modified for spatial constraints
% obj_fcn = sum(sum((dist.^2).*mf));
obj_fcn.fcm = sum(sum((dist.^2).*mf));
obj_fcn.spatial =  beta / 2 * sum(sum(mf .* snom));
obj_fcn.total = obj_fcn.fcm + obj_fcn.spatial;

tmp = (dist.^2 + beta * snom).^(-1/(expo-1));      % calculate new U, suppose expo != 1

% U_new is modified for spatial constraints
U_new = tmp./(ones(cluster_n, 1)*sum(tmp));
